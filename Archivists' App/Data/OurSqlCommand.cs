using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using Devart.Data.PostgreSql;

namespace SoundExplorers.Data {

    /// <summary>
    /// Represents an SQL statement to execute against the 
    /// SoundExplorers database for an Entity
    /// of the specified type.
    /// </summary>
    internal abstract class OurSqlCommand<T> : PgSqlCommand
        where T : Entity<T> {

        #region Private Fields
        private string _sqlFilename;
        #endregion Private Fields

        #region Protected Properties
        protected IEntity Entity { get; set; }
        #endregion Protected Properties

        #region Public Properties
        /// <summary>
        /// Gets or sets the SQL statement to execute against the database.
        /// </summary>
        /// <remarks>
        /// If null or empty, an attempt will be made to read the SQL 
        /// from an embedded resource file.
        /// If the embedded resource file cannot be found,
        /// an attempt will be made to generate the
        /// SQL from metadata derived from 
        /// the specified Entity type.
        /// </remarks>
        public override string CommandText {
            get {
                if (string.IsNullOrEmpty(base.CommandText)) {
                    try {
                        base.CommandText = SqlHelper.GetSql(SqlFilename);
                    } catch (FileNotFoundException) {
                        base.CommandText = GenerateSql();
                    }
                }
                return base.CommandText;
            }
            set {
                base.CommandText = value;
            }
        }
        #endregion Public Properties

        #region Protected Properties
        /// <summary>
        /// Gets metadata about the database columns
        /// represented by the Entity's
        /// field properties.
        /// </summary>
        protected EntityColumnList Columns { get; private set; }

        /// <summary>
        /// Gets the <see cref="System.Type"/> of the specified Entity.
        /// </summary>
        protected virtual Type EntityType { get; private set; }

        /// <summary>
        /// Gets metadata about those database columns
        /// represented by the Entity's
        /// field properties that are in
        /// the primary key required for database access.
        /// </summary>
        protected EntityColumnList PrimaryKeyColumns { get; private set; }

        /// <summary>
        /// Gets metadata about those database columns
        /// represented by the Entity's
        /// field properties that are NOT in
        /// the primary key required for database access.
        /// </summary>
        protected EntityColumnList NonPrimaryKeyColumns { get; private set; }

        /// <summary>
        /// Gets or sets the name of an embedded resource file
        /// within the Sql folder of the Data folder
        /// of the executing assembly's project
        /// containing the SQL for the command text.
        /// The default is 
        /// "SQL_TYPE ENTITY_TYPE.sql",
        /// where SQL_TYPE is the name of the type of SQL command 
        /// (Delete / Insert / Select / Update)
        /// represented by the derived class.
        /// and ENTITY_TYPE is the name of the type of
        /// <see cref="Entity"/> listed
        /// </summary>
        /// <remarks>
        /// If the embedded resource file cannot be found
        /// (the file's Build Action property must be set to 
        /// "Embedded Resource"),
        /// an attempt will be made to generate the
        /// SQL from metadata derived from the type of
        /// Entity.
        /// </remarks>
        protected virtual string SqlFilename {
            get {
                if (_sqlFilename == null) {
                    _sqlFilename = 
                        SqlTypeName.ToString() + " " + EntityType.Name + ".sql";
                }
                return _sqlFilename;
            }
            set {
                _sqlFilename = value;
            }
        }

        /// <summary>
        /// Gets the name of the type of SQL command 
        /// represented by the derived class.
        /// </summary>
        protected virtual string SqlTypeName { get; private set; }
        #endregion Protected Properties

        #region Private Properties
        /// <summary>
        /// Whether the SQL command parameters were
        /// automatically generated by the constructor
        /// via the <see cref="CreateParameters"/> method.
        /// </summary>
        private bool WereParametersGenerated;
        #endregion Private Properties

        #region Constructors
        /// <summary>
        /// Initialises a new instance of the <see cref="OurSqlCommand"/> class, 
        /// creating its <see cref="PgSqlConnection.Connection"/>.
        /// </summary>
        public OurSqlCommand() {
            EntityType = typeof(T);
            string typeName = this.GetType().Name;
            SqlTypeName = typeName.Substring(0, typeName.IndexOf("Command"));
            Entity = new Entity<T>();
            Columns = Entity.Columns;
            PrimaryKeyColumns = Entity.PrimaryKeyColumns;
            NonPrimaryKeyColumns = Entity.NonPrimaryKeyColumns;
            this.Connection = new PgSqlConnection(
                SqlHelper.ConnectionString);
        }
        #endregion Constructors

        #region Public Methods
        /// <summary>
        /// Validates and prepares the SQL command.
        /// </summary>
        /// <exception cref="ApplicationException">
        /// A parameter placeholder 
        /// that does not match an entity field property parameter
        /// has been found in the SQL command text.
        /// </exception>
        /// <exception cref="DataException">
        /// Error on preparing the SQL command.
        /// </exception>
        public override void Prepare() {
            // Calling ValidateParameterPlaceholders
            // before base.Prepare
            // sometimes (INSERT command of CreditList)
            // makes base.Prepare throw a PgSqlException
            // "Parameter name is missing".
            //ValidateParameterPlaceholders();
            try {
                this.Connection.Open();
                base.Prepare();
            } catch (PgSqlException ex) {
                throw new DataException(
                    "Error on preparing "
                    + SqlTypeName.ToUpper() + " command:" + Environment.NewLine
                    + ex.Message + Environment.NewLine + Environment.NewLine
                    + "SQL command text:" + Environment.NewLine + Environment.NewLine
                    + CommandText 
                    + Environment.NewLine,
                    ex);
            } finally {
                this.Connection.Close();
            }
            // Parameter placeholders in SQL templates
            // need only match columns of the current entity
            // when the parameters were automatically generated
            // by the constructor
            // via the CreateParameters method
            // from columns of this entity.
            if (WereParametersGenerated) {
                ValidateParameterPlaceholders();
            }
        }

        /// <summary>
        /// Converts a .Net type to a <see cref="System.Data.DbType"/>,
        /// as required for the specification of an SQL command parameter.
        /// </summary>
        /// <param name="type">
        /// A .Net type, 
        /// in this cas the type one of the listed Entity's field properties.</param>
        /// <returns>
        /// A data type required for the specification of an SQL command parameter.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Conversion of the specified type is not currently supported.
        /// </exception>
        public static DbType TypeToDbType(Type type) {
            if (type == typeof(DateTime)) {
                return DbType.Date;
            } else if (type == typeof(int)) {
                return DbType.Int32;
            } else if (type == typeof(string)) {
                return DbType.String;
            } else {
                throw new ArgumentOutOfRangeException(
                    "type",
                    type,
                    "Conversion of type " + type.Name
                    + " to an equivalent DbType is not currently supported.");
            }
        }
        #endregion Public Methods

        #region Protected Methods
        /// <summary>
        /// Creates the parameters required for the SQL command.
        /// </summary>
        /// <param name="keyColumsOnly">
        /// Whether parameters are to be returned only for primary key columns.
        /// </param>
        /// <returns>
        /// An array of the created parameters.
        /// </returns>
        protected virtual PgSqlParameter[] CreateParameters(bool keyColumsOnly) {
            var parameters = new List<PgSqlParameter>(Entity.Columns.Count());
            foreach (EntityColumn<T> column in Entity.Columns) {
                if (!keyColumsOnly || column.IsInPrimaryKey) {
                    var parameter = new PgSqlParameter();
                    parameter.ParameterName = "@" + column.ColumnName;
                    parameter.SourceColumn = column.ColumnName;
                    parameter.DbType = TypeToDbType(column.DataType);
                    parameters.Add(parameter);
                }
            } // End of foreach
            WereParametersGenerated = true;
            return parameters.ToArray();
        }

        /// <summary>
        /// Generates the SQL command text 
        /// from metadata derived from the type of
        /// Entity.
        /// </summary>
        /// <returns>
        /// The SQL text generated.
        /// </returns>
        protected abstract string GenerateSql();

        /// <summary>
        /// Generates the SQL column list
        /// for SELECT and INSERT commands.
        /// </summary>
        /// <returns>
        /// The SQL fragment generated.
        /// </returns>
        protected virtual string GenerateSqlColumnList() {
            var sql = new StringWriter();
            for (int i = 0; i < Columns.Count(); i++) {
                sql.Write("    " + Columns[i].NameOnDb);
                if (i < Columns.Count() - 1) {
                    sql.WriteLine(",");
                } else {
                    sql.WriteLine();
                }
            } // End of for
            return sql.ToString();
        }

        /// <summary>
        /// Generates the SQL WHERE clause
        /// for DELETE, INSERT and UPDATE commands.
        /// </summary>
        /// <returns>
        /// The SQL fragment generated.
        /// </returns>
        protected virtual string GenerateSqlWhereClause() {
            var sql = new StringWriter();
            sql.Write("where ");
            for (int i = 0; i < PrimaryKeyColumns.Count(); i++) {
                sql.Write(PrimaryKeyColumns[i].NameOnDb + " = @" + PrimaryKeyColumns[i].ColumnName);
                sql.WriteLine();
                if (i < PrimaryKeyColumns.Count() - 1) {
                    sql.Write("and ");
                }
            } // End of for
            return sql.ToString();
        }
        #endregion Protected Methods

        #region Private Methods
        /// <summary>
        /// Returns an alphabetical unique array
        /// of the parameter placeholders, including the leading "@"s,
        /// found in the command text.
        /// </summary>
        /// <returns>
        /// The parameter placeholders, including the leading "@"s,
        /// found in the command text.
        /// </returns>
        /// <remarks>
        /// A parameter placeholder  must be prefixed
        /// by a @ character. 
        /// The next character must be a letter.
        /// Subsequent character may be letters, digits
        /// or underscores.  
        /// </remarks>
        private string[] GetParameterPlaceholders() {
            // This thorough method allows for the
            // unlikely event that one parameter placeholder is
            // the same as the start of another.  For example:
            // @Cost and @CostCode.
            var placeholders = new List<string>();
            bool characterIsInPlaceholder = false;
            StringBuilder placeholderBuilder = null;
            // For unknown reason, base.CommandText is blank
            // unless there's a breakpoint here or earlier.
            foreach (char character in CommandText.TrimEnd().ToCharArray()) {
            //foreach (char character in base.CommandText.TrimEnd().ToCharArray()) {
                if (character == '@') {
                    characterIsInPlaceholder = true;
                    placeholderBuilder = new StringBuilder();
                    placeholderBuilder.Append(character);
                } else if (characterIsInPlaceholder) {
                    if (placeholderBuilder.Length == 1) {
                        if (char.IsLetter(character)) {
                            placeholderBuilder.Append(character);
                        } else {
                            characterIsInPlaceholder = false;
                        }
                    } else if (char.IsLetterOrDigit(character)
                        || character == '_') {
                        placeholderBuilder.Append(character);
                    } else {
                        characterIsInPlaceholder = false;
                        if (!placeholders.Contains(placeholderBuilder.ToString())) {
                            placeholders.Add(placeholderBuilder.ToString());
                        }
                    }
                }
            }//End of foreach
            if (characterIsInPlaceholder) {
                // The last word in the command text is a parameter placeholder.
                if (!placeholders.Contains(placeholderBuilder.ToString())) {
                    placeholders.Add(placeholderBuilder.ToString());
                }
            }
            placeholders.Sort();
            return placeholders.ToArray();
        }

        /// <summary>
        /// Validates the parameter placeholders
        /// found in the command text
        /// by ensuring that each of them matches a parameter
        /// that has been generated from an entity field property
        /// by the <see cref="CreateParameters"/> method.
        /// </summary>
        /// <exception cref="ApplicationException">
        /// A parameter placeholder 
        /// that does not match an entity field property parameter
        /// has been found in the SQL command text.
        /// </exception>
        /// <remarks>
        /// If the command has the same number of parameters as the entity has primary key field properties
        /// or the parameter placeholder to be matched starts with "@OLD_",
        /// the parameter placeholder will be assumed to be required to match
        /// one of the entity's primary key field properties.
        /// A parameter placeholder matches an entity field property
        /// if the parameter placeholder is 
        /// the property name prefixed by either "@" or "@OLD_".
        /// </remarks>
        private void ValidateParameterPlaceholders() {
            string[] placeholders = GetParameterPlaceholders();
            //foreach (PgSqlParameter parameter in Parameters) {
            //    Debug.WriteLine(parameter.ParameterName);
            //}
            foreach (string placeholder in placeholders) {
                //Debug.WriteLine(placeholder);
                bool fieldPropertyFound;
                if (placeholder.StartsWith("@OLD_")) {
                    fieldPropertyFound = 
                        PrimaryKeyColumns.ContainsKey(placeholder.Replace("@OLD_", string.Empty));
                } else if (Parameters.Count == PrimaryKeyColumns.Count()) {
                    fieldPropertyFound =
                        PrimaryKeyColumns.ContainsKey(placeholder.Replace("@", string.Empty));
                } else {
                    fieldPropertyFound =
                        Columns.ContainsKey(placeholder.Replace("@", string.Empty));
                }
                if (!fieldPropertyFound) {
                    string message =
                        "Error in "
                        + SqlTypeName.ToUpper() + " command:" + Environment.NewLine
                        + "Entity class " + EntityType.Name
                        + " does not contain ";
                    if (Parameters.Count < Columns.Count()
                    ||  placeholder.StartsWith("@OLD_")) {
                        message += "key ";
                    }
                    message += "field property ";
                    if (placeholder.StartsWith("@OLD_")) {
                        message += placeholder.Replace("@OLD_", string.Empty);
                    } else {
                        message += placeholder.Replace("@", string.Empty);
                    }
                    message +=
                        " to match parameter placeholder " + placeholder
                        + " found in the SQL command text."
                        + Environment.NewLine + Environment.NewLine
                        + "SQL command text:" + Environment.NewLine + Environment.NewLine
                        + base.CommandText;
                    throw new ApplicationException(message);
                }
            }
        }
        #endregion Private Methods
    }//End of class
}//End of namespace